/* tslint:disable */
/* eslint-disable */
/*
Snyk API

Missing description placeholder

The version of the OpenAPI document: REST


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ErrorDocument } from '../models';
// @ts-ignore
import { PatchProjectRequest } from '../models';
// @ts-ignore
import { PatchProjectRequestData } from '../models';
// @ts-ignore
import { ProjectsGetByProjectIdResponse } from '../models';
// @ts-ignore
import { ProjectsListForOrgResponse } from '../models';
// @ts-ignore
import { ProjectsUpdateByProjectIdResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete one project in the organization by project ID.
         * @summary Delete project by project ID.
         * @param {string} orgId The ID of the org to which the project belongs to.
         * @param {string} projectId The ID of the project.
         * @param {string} version The requested version of the endpoint to process the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByProjectId: async (orgId: string, projectId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteByProjectId', 'orgId', orgId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteByProjectId', 'projectId', projectId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('deleteByProjectId', 'version', version)
            const localVarPath = `/orgs/{org_id}/projects/{project_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId !== undefined ? orgId : `-org_id-`)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId !== undefined ? projectId : `-project_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "aPIToken", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/orgs/{org_id}/projects/{project_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get one project of the organization by project ID.
         * @summary Get project by project ID.
         * @param {string} orgId The ID of the org to which the project belongs to.
         * @param {string} projectId The ID of the project.
         * @param {string} version The requested version of the endpoint to process the request
         * @param {Array<'target'>} [expand] Expand relationships.
         * @param {boolean} [metaLatestIssueCounts] Include a summary count for the issues found in the most recent scan of this project
         * @param {boolean} [metaLatestDependencyTotal] Include the total number of dependencies found in the most recent scan of this project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByProjectId: async (orgId: string, projectId: string, version: string, expand?: Array<'target'>, metaLatestIssueCounts?: boolean, metaLatestDependencyTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getByProjectId', 'orgId', orgId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getByProjectId', 'projectId', projectId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getByProjectId', 'version', version)
            const localVarPath = `/orgs/{org_id}/projects/{project_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId !== undefined ? orgId : `-org_id-`)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId !== undefined ? projectId : `-project_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "aPIToken", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (expand) {
                localVarQueryParameter['expand'] = expand.join(COLLECTION_FORMATS.csv);
            }

            if (metaLatestIssueCounts !== undefined) {
                localVarQueryParameter['meta.latest_issue_counts'] = metaLatestIssueCounts;
            }

            if (metaLatestDependencyTotal !== undefined) {
                localVarQueryParameter['meta.latest_dependency_total'] = metaLatestDependencyTotal;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/orgs/{org_id}/projects/{project_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Projects for an Org.
         * @summary List all Projects for an Org with the given Org ID.
         * @param {string} orgId The ID of the org that the projects belong to.
         * @param {string} version The requested version of the endpoint to process the request
         * @param {Array<string>} [targetId] Return projects that belong to the provided targets
         * @param {string} [targetReference] Return projects that match the provided target reference
         * @param {string} [targetFile] Return projects that match the provided target file
         * @param {string} [targetRuntime] Return projects that match the provided target runtime
         * @param {'only'} [metaCount] The collection count.
         * @param {Array<string>} [ids] Return projects that match the provided IDs.
         * @param {Array<string>} [names] Return projects that match the provided names.
         * @param {Array<string>} [namesStartWith] Return projects with names starting with the specified prefix.
         * @param {Array<string>} [origins] Return projects that match the provided origins.
         * @param {Array<string>} [types] Return projects that match the provided types.
         * @param {Array<'target'>} [expand] Expand relationships.
         * @param {boolean} [metaLatestIssueCounts] Include a summary count for the issues found in the most recent scan of this project
         * @param {boolean} [metaLatestDependencyTotal] Include the total number of dependencies found in the most recent scan of this project
         * @param {string} [cliMonitoredBefore] Filter projects uploaded and monitored before this date (encoded value)
         * @param {string} [cliMonitoredAfter] Filter projects uploaded and monitored after this date (encoded value)
         * @param {Array<string>} [importingUserPublicId] Return projects that match the provided importing user public ids.
         * @param {Array<string>} [tags] Return projects that match all the provided tags
         * @param {Array<'critical' | 'high' | 'medium' | 'low'>} [businessCriticality] Return projects that match all the provided business_criticality value
         * @param {Array<'frontend' | 'backend' | 'internal' | 'external' | 'mobile' | 'saas' | 'onprem' | 'hosted' | 'distributed'>} [environment] Return projects that match all the provided environment values
         * @param {Array<'production' | 'development' | 'sandbox'>} [lifecycle] Return projects that match all the provided lifecycle values
         * @param {string} [startingAfter] Return the page of results immediately after this cursor
         * @param {string} [endingBefore] Return the page of results immediately before this cursor
         * @param {number} [limit] Number of results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForOrg: async (orgId: string, version: string, targetId?: Array<string>, targetReference?: string, targetFile?: string, targetRuntime?: string, metaCount?: 'only', ids?: Array<string>, names?: Array<string>, namesStartWith?: Array<string>, origins?: Array<string>, types?: Array<string>, expand?: Array<'target'>, metaLatestIssueCounts?: boolean, metaLatestDependencyTotal?: boolean, cliMonitoredBefore?: string, cliMonitoredAfter?: string, importingUserPublicId?: Array<string>, tags?: Array<string>, businessCriticality?: Array<'critical' | 'high' | 'medium' | 'low'>, environment?: Array<'frontend' | 'backend' | 'internal' | 'external' | 'mobile' | 'saas' | 'onprem' | 'hosted' | 'distributed'>, lifecycle?: Array<'production' | 'development' | 'sandbox'>, startingAfter?: string, endingBefore?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listForOrg', 'orgId', orgId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('listForOrg', 'version', version)
            const localVarPath = `/orgs/{org_id}/projects`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId !== undefined ? orgId : `-org_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "aPIToken", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (targetId) {
                localVarQueryParameter['target_id'] = targetId;
            }

            if (targetReference !== undefined) {
                localVarQueryParameter['target_reference'] = targetReference;
            }

            if (targetFile !== undefined) {
                localVarQueryParameter['target_file'] = targetFile;
            }

            if (targetRuntime !== undefined) {
                localVarQueryParameter['target_runtime'] = targetRuntime;
            }

            if (metaCount !== undefined) {
                localVarQueryParameter['meta_count'] = metaCount;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }

            if (names) {
                localVarQueryParameter['names'] = names.join(COLLECTION_FORMATS.csv);
            }

            if (namesStartWith) {
                localVarQueryParameter['names_start_with'] = namesStartWith.join(COLLECTION_FORMATS.csv);
            }

            if (origins) {
                localVarQueryParameter['origins'] = origins.join(COLLECTION_FORMATS.csv);
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand.join(COLLECTION_FORMATS.csv);
            }

            if (metaLatestIssueCounts !== undefined) {
                localVarQueryParameter['meta.latest_issue_counts'] = metaLatestIssueCounts;
            }

            if (metaLatestDependencyTotal !== undefined) {
                localVarQueryParameter['meta.latest_dependency_total'] = metaLatestDependencyTotal;
            }

            if (cliMonitoredBefore !== undefined) {
                localVarQueryParameter['cli_monitored_before'] = (cliMonitoredBefore as any instanceof Date) ?
                    (cliMonitoredBefore as any).toISOString() :
                    cliMonitoredBefore;
            }

            if (cliMonitoredAfter !== undefined) {
                localVarQueryParameter['cli_monitored_after'] = (cliMonitoredAfter as any instanceof Date) ?
                    (cliMonitoredAfter as any).toISOString() :
                    cliMonitoredAfter;
            }

            if (importingUserPublicId) {
                localVarQueryParameter['importing_user_public_id'] = importingUserPublicId.join(COLLECTION_FORMATS.csv);
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (businessCriticality) {
                localVarQueryParameter['business_criticality'] = businessCriticality.join(COLLECTION_FORMATS.csv);
            }

            if (environment) {
                localVarQueryParameter['environment'] = environment.join(COLLECTION_FORMATS.csv);
            }

            if (lifecycle) {
                localVarQueryParameter['lifecycle'] = lifecycle.join(COLLECTION_FORMATS.csv);
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (startingAfter !== undefined) {
                localVarQueryParameter['starting_after'] = startingAfter;
            }

            if (endingBefore !== undefined) {
                localVarQueryParameter['ending_before'] = endingBefore;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/orgs/{org_id}/projects',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates one project of the organization by project ID.
         * @summary Updates project by project ID.
         * @param {string} version The requested version of the endpoint to process the request
         * @param {string} orgId The ID of the Org the project belongs to.
         * @param {string} projectId The ID of the project to patch.
         * @param {Array<'target'>} [expand] Expand relationships.
         * @param {PatchProjectRequest} [patchProjectRequest] The project attributes to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateByProjectId: async (version: string, orgId: string, projectId: string, expand?: Array<'target'>, patchProjectRequest?: PatchProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('updateByProjectId', 'version', version)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateByProjectId', 'orgId', orgId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateByProjectId', 'projectId', projectId)
            const localVarPath = `/orgs/{org_id}/projects/{project_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId !== undefined ? orgId : `-org_id-`)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId !== undefined ? projectId : `-project_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIToken required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "aPIToken", configuration })
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand.join(COLLECTION_FORMATS.csv);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: patchProjectRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/orgs/{org_id}/projects/{project_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(patchProjectRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete one project in the organization by project ID.
         * @summary Delete project by project ID.
         * @param {ProjectsApiDeleteByProjectIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteByProjectId(requestParameters: ProjectsApiDeleteByProjectIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteByProjectId(requestParameters.orgId, requestParameters.projectId, requestParameters.version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get one project of the organization by project ID.
         * @summary Get project by project ID.
         * @param {ProjectsApiGetByProjectIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByProjectId(requestParameters: ProjectsApiGetByProjectIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsGetByProjectIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByProjectId(requestParameters.orgId, requestParameters.projectId, requestParameters.version, requestParameters.expand, requestParameters.metaLatestIssueCounts, requestParameters.metaLatestDependencyTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all Projects for an Org.
         * @summary List all Projects for an Org with the given Org ID.
         * @param {ProjectsApiListForOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForOrg(requestParameters: ProjectsApiListForOrgRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsListForOrgResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForOrg(requestParameters.orgId, requestParameters.version, requestParameters.targetId, requestParameters.targetReference, requestParameters.targetFile, requestParameters.targetRuntime, requestParameters.metaCount, requestParameters.ids, requestParameters.names, requestParameters.namesStartWith, requestParameters.origins, requestParameters.types, requestParameters.expand, requestParameters.metaLatestIssueCounts, requestParameters.metaLatestDependencyTotal, requestParameters.cliMonitoredBefore, requestParameters.cliMonitoredAfter, requestParameters.importingUserPublicId, requestParameters.tags, requestParameters.businessCriticality, requestParameters.environment, requestParameters.lifecycle, requestParameters.startingAfter, requestParameters.endingBefore, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates one project of the organization by project ID.
         * @summary Updates project by project ID.
         * @param {ProjectsApiUpdateByProjectIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateByProjectId(requestParameters: ProjectsApiUpdateByProjectIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsUpdateByProjectIdResponse>> {
            const patchProjectRequest: PatchProjectRequest = {
                data: requestParameters.data
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateByProjectId(requestParameters.version, requestParameters.orgId, requestParameters.projectId, requestParameters.expand, patchProjectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Delete one project in the organization by project ID.
         * @summary Delete project by project ID.
         * @param {ProjectsApiDeleteByProjectIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByProjectId(requestParameters: ProjectsApiDeleteByProjectIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteByProjectId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get one project of the organization by project ID.
         * @summary Get project by project ID.
         * @param {ProjectsApiGetByProjectIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByProjectId(requestParameters: ProjectsApiGetByProjectIdRequest, options?: AxiosRequestConfig): AxiosPromise<ProjectsGetByProjectIdResponse> {
            return localVarFp.getByProjectId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all Projects for an Org.
         * @summary List all Projects for an Org with the given Org ID.
         * @param {ProjectsApiListForOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForOrg(requestParameters: ProjectsApiListForOrgRequest, options?: AxiosRequestConfig): AxiosPromise<ProjectsListForOrgResponse> {
            return localVarFp.listForOrg(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates one project of the organization by project ID.
         * @summary Updates project by project ID.
         * @param {ProjectsApiUpdateByProjectIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateByProjectId(requestParameters: ProjectsApiUpdateByProjectIdRequest, options?: AxiosRequestConfig): AxiosPromise<ProjectsUpdateByProjectIdResponse> {
            return localVarFp.updateByProjectId(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteByProjectId operation in ProjectsApi.
 * @export
 * @interface ProjectsApiDeleteByProjectIdRequest
 */
export type ProjectsApiDeleteByProjectIdRequest = {
    
    /**
    * The ID of the org to which the project belongs to.
    * @type {string}
    * @memberof ProjectsApiDeleteByProjectId
    */
    readonly orgId: string
    
    /**
    * The ID of the project.
    * @type {string}
    * @memberof ProjectsApiDeleteByProjectId
    */
    readonly projectId: string
    
    /**
    * The requested version of the endpoint to process the request
    * @type {string}
    * @memberof ProjectsApiDeleteByProjectId
    */
    readonly version: string
    
}

/**
 * Request parameters for getByProjectId operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetByProjectIdRequest
 */
export type ProjectsApiGetByProjectIdRequest = {
    
    /**
    * The ID of the org to which the project belongs to.
    * @type {string}
    * @memberof ProjectsApiGetByProjectId
    */
    readonly orgId: string
    
    /**
    * The ID of the project.
    * @type {string}
    * @memberof ProjectsApiGetByProjectId
    */
    readonly projectId: string
    
    /**
    * The requested version of the endpoint to process the request
    * @type {string}
    * @memberof ProjectsApiGetByProjectId
    */
    readonly version: string
    
    /**
    * Expand relationships.
    * @type {Array<'target'>}
    * @memberof ProjectsApiGetByProjectId
    */
    readonly expand?: Array<'target'>
    
    /**
    * Include a summary count for the issues found in the most recent scan of this project
    * @type {boolean}
    * @memberof ProjectsApiGetByProjectId
    */
    readonly metaLatestIssueCounts?: boolean
    
    /**
    * Include the total number of dependencies found in the most recent scan of this project
    * @type {boolean}
    * @memberof ProjectsApiGetByProjectId
    */
    readonly metaLatestDependencyTotal?: boolean
    
}

/**
 * Request parameters for listForOrg operation in ProjectsApi.
 * @export
 * @interface ProjectsApiListForOrgRequest
 */
export type ProjectsApiListForOrgRequest = {
    
    /**
    * The ID of the org that the projects belong to.
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly orgId: string
    
    /**
    * The requested version of the endpoint to process the request
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly version: string
    
    /**
    * Return projects that belong to the provided targets
    * @type {Array<string>}
    * @memberof ProjectsApiListForOrg
    */
    readonly targetId?: Array<string>
    
    /**
    * Return projects that match the provided target reference
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly targetReference?: string
    
    /**
    * Return projects that match the provided target file
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly targetFile?: string
    
    /**
    * Return projects that match the provided target runtime
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly targetRuntime?: string
    
    /**
    * The collection count.
    * @type {'only'}
    * @memberof ProjectsApiListForOrg
    */
    readonly metaCount?: 'only'
    
    /**
    * Return projects that match the provided IDs.
    * @type {Array<string>}
    * @memberof ProjectsApiListForOrg
    */
    readonly ids?: Array<string>
    
    /**
    * Return projects that match the provided names.
    * @type {Array<string>}
    * @memberof ProjectsApiListForOrg
    */
    readonly names?: Array<string>
    
    /**
    * Return projects with names starting with the specified prefix.
    * @type {Array<string>}
    * @memberof ProjectsApiListForOrg
    */
    readonly namesStartWith?: Array<string>
    
    /**
    * Return projects that match the provided origins.
    * @type {Array<string>}
    * @memberof ProjectsApiListForOrg
    */
    readonly origins?: Array<string>
    
    /**
    * Return projects that match the provided types.
    * @type {Array<string>}
    * @memberof ProjectsApiListForOrg
    */
    readonly types?: Array<string>
    
    /**
    * Expand relationships.
    * @type {Array<'target'>}
    * @memberof ProjectsApiListForOrg
    */
    readonly expand?: Array<'target'>
    
    /**
    * Include a summary count for the issues found in the most recent scan of this project
    * @type {boolean}
    * @memberof ProjectsApiListForOrg
    */
    readonly metaLatestIssueCounts?: boolean
    
    /**
    * Include the total number of dependencies found in the most recent scan of this project
    * @type {boolean}
    * @memberof ProjectsApiListForOrg
    */
    readonly metaLatestDependencyTotal?: boolean
    
    /**
    * Filter projects uploaded and monitored before this date (encoded value)
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly cliMonitoredBefore?: string
    
    /**
    * Filter projects uploaded and monitored after this date (encoded value)
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly cliMonitoredAfter?: string
    
    /**
    * Return projects that match the provided importing user public ids.
    * @type {Array<string>}
    * @memberof ProjectsApiListForOrg
    */
    readonly importingUserPublicId?: Array<string>
    
    /**
    * Return projects that match all the provided tags
    * @type {Array<string>}
    * @memberof ProjectsApiListForOrg
    */
    readonly tags?: Array<string>
    
    /**
    * Return projects that match all the provided business_criticality value
    * @type {Array<'critical' | 'high' | 'medium' | 'low'>}
    * @memberof ProjectsApiListForOrg
    */
    readonly businessCriticality?: Array<'critical' | 'high' | 'medium' | 'low'>
    
    /**
    * Return projects that match all the provided environment values
    * @type {Array<'frontend' | 'backend' | 'internal' | 'external' | 'mobile' | 'saas' | 'onprem' | 'hosted' | 'distributed'>}
    * @memberof ProjectsApiListForOrg
    */
    readonly environment?: Array<'frontend' | 'backend' | 'internal' | 'external' | 'mobile' | 'saas' | 'onprem' | 'hosted' | 'distributed'>
    
    /**
    * Return projects that match all the provided lifecycle values
    * @type {Array<'production' | 'development' | 'sandbox'>}
    * @memberof ProjectsApiListForOrg
    */
    readonly lifecycle?: Array<'production' | 'development' | 'sandbox'>
    
    /**
    * Return the page of results immediately after this cursor
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly startingAfter?: string
    
    /**
    * Return the page of results immediately before this cursor
    * @type {string}
    * @memberof ProjectsApiListForOrg
    */
    readonly endingBefore?: string
    
    /**
    * Number of results to return per page
    * @type {number}
    * @memberof ProjectsApiListForOrg
    */
    readonly limit?: number
    
}

/**
 * Request parameters for updateByProjectId operation in ProjectsApi.
 * @export
 * @interface ProjectsApiUpdateByProjectIdRequest
 */
export type ProjectsApiUpdateByProjectIdRequest = {
    
    /**
    * The requested version of the endpoint to process the request
    * @type {string}
    * @memberof ProjectsApiUpdateByProjectId
    */
    readonly version: string
    
    /**
    * The ID of the Org the project belongs to.
    * @type {string}
    * @memberof ProjectsApiUpdateByProjectId
    */
    readonly orgId: string
    
    /**
    * The ID of the project to patch.
    * @type {string}
    * @memberof ProjectsApiUpdateByProjectId
    */
    readonly projectId: string
    
    /**
    * Expand relationships.
    * @type {Array<'target'>}
    * @memberof ProjectsApiUpdateByProjectId
    */
    readonly expand?: Array<'target'>
    
} & PatchProjectRequest

/**
 * ProjectsApiGenerated - object-oriented interface
 * @export
 * @class ProjectsApiGenerated
 * @extends {BaseAPI}
 */
export class ProjectsApiGenerated extends BaseAPI {
    /**
     * Delete one project in the organization by project ID.
     * @summary Delete project by project ID.
     * @param {ProjectsApiDeleteByProjectIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiGenerated
     */
    public deleteByProjectId(requestParameters: ProjectsApiDeleteByProjectIdRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteByProjectId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get one project of the organization by project ID.
     * @summary Get project by project ID.
     * @param {ProjectsApiGetByProjectIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiGenerated
     */
    public getByProjectId(requestParameters: ProjectsApiGetByProjectIdRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getByProjectId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all Projects for an Org.
     * @summary List all Projects for an Org with the given Org ID.
     * @param {ProjectsApiListForOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiGenerated
     */
    public listForOrg(requestParameters: ProjectsApiListForOrgRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listForOrg(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates one project of the organization by project ID.
     * @summary Updates project by project ID.
     * @param {ProjectsApiUpdateByProjectIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiGenerated
     */
    public updateByProjectId(requestParameters: ProjectsApiUpdateByProjectIdRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateByProjectId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
